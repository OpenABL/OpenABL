// Based on FlameGPU implementation

// TODO INITIAL PORT -- NOT TESTED!

agent Agent {
  position float2 pos;
  float2 target_pos;
  int state;
  int sugar_level;
  int metabolism;
  int env_sugar_level;
  int max_env_sugar_level;
}

int AGENT_STATE_UNOCCUPIED = 0;
int AGENT_STATE_OCCUPIED = 1;
int AGENT_STATE_MOVEMENT_REQUESTED = 2;
int AGENT_STATE_MOVEMENT_UNRESOLVED = 3;

int SUGAR_GROWBACK_RATE = 1;
int min_start_sugar_level = 1;
int max_start_sugar_level = 10;

// TODO This takes into account all direct neightbors,
//      should only use horizontal and vertical instead?
float radius = 1.5;

param int num_timesteps = 100;
param int grid_width = 50;
param float occupiedFrac = 0.2;

float2 sugar_center1 = float2(0.25, 0.25) * grid_width;
float2 sugar_center2 = float2(0.75, 0.75) * grid_width;
int global_max_env_sugar_level = 100;
float sugar_variance = 0.7 * grid_width;

environment {
  max: float2(grid_width)
}

// For visualization
int getColor(Agent cell) {
  float frac = min(1.0, float(cell.env_sugar_level) / float(global_max_env_sugar_level));
  int c = int(255 * (1 - frac));
  int rgb = 0xff00ff | (c << 8);
  if (cell.state == AGENT_STATE_UNOCCUPIED) {
    return rgb;
  }
  // TODO Show more state
  return cell.state == AGENT_STATE_OCCUPIED ? 0x000000 : 0xff0000;
}

void metabolise_and_growback(Agent in -> out) {
  if (in.state == AGENT_STATE_OCCUPIED) {
    // Store sugar and metabolise
    out.sugar_level = in.sugar_level + in.env_sugar_level - in.metabolism;
    out.env_sugar_level = 0;

    if (out.sugar_level == 0) {
      // Agent dies
      out.state = AGENT_STATE_UNOCCUPIED;
      out.metabolism = 0;
    } else {
      // Agent may want to move
      out.state = AGENT_STATE_MOVEMENT_UNRESOLVED;
    }
  } else if (in.state == AGENT_STATE_UNOCCUPIED) {
    int new_env_sugar_level = in.env_sugar_level + SUGAR_GROWBACK_RATE;
    if (new_env_sugar_level > in.max_env_sugar_level) {
      new_env_sugar_level = in.max_env_sugar_level;
    }
    out.env_sugar_level = new_env_sugar_level;
  }
}

void movement_request(Agent in -> out) {
  if (in.state == AGENT_STATE_MOVEMENT_UNRESOLVED) {
    int best_sugar_level = -1;
    float2 best_pos = float2(0);
    for (Agent nx : near(in, radius)) {
      if (nx.pos == in.pos) continue;
      if (nx.state == AGENT_STATE_UNOCCUPIED && nx.env_sugar_level > best_sugar_level) {
        best_sugar_level = nx.env_sugar_level;
        best_pos = nx.pos;
      }
    }

    if (best_sugar_level >= 0) {
      out.state = AGENT_STATE_MOVEMENT_REQUESTED;
      out.target_pos = best_pos;
    } else {
      out.state = AGENT_STATE_OCCUPIED;
    }
  }
}

void movement_response(Agent in -> out) {
  if (in.state == AGENT_STATE_UNOCCUPIED) {
    int best_priority = -1;
    int best_sugar_level = -1;
    int best_metabolism = -1;

    for (Agent nx : near(in, radius)) {
      if (nx.state == AGENT_STATE_MOVEMENT_REQUESTED && nx.target_pos == in.pos) {
        // ??? FlameGPU model simply picks the first, effectively
        int message_priority = 0;
        if (message_priority > best_priority) {
          best_priority = message_priority;
          best_sugar_level = nx.sugar_level;
          best_metabolism = nx.metabolism;
        }
      }
    }

    if (best_priority >= 0) {
      out.state = AGENT_STATE_OCCUPIED;
      out.sugar_level = best_sugar_level;
      out.metabolism = best_metabolism;
    }
  }
}

void movement_transaction(Agent in -> out) {
  if (in.state == AGENT_STATE_MOVEMENT_REQUESTED) {
    for (Agent nx : near(in, radius)) {
      if (nx.state == AGENT_STATE_OCCUPIED && nx.pos == in.target_pos) {
        out.state = AGENT_STATE_UNOCCUPIED;
        out.sugar_level = 0;
        out.metabolism = 0;
      }
    }
    if (out.state == AGENT_STATE_MOVEMENT_REQUESTED) {
      out.state = AGENT_STATE_OCCUPIED;
    }
  }
}

int get_max_env_sugar_level(int x, int y) {
  int gmax = global_max_env_sugar_level;
  float2 pos = float2(x, y);
  int max = 0;
  float d1 = dist(pos, sugar_center1);
  max += gmax * exp(-d1*d1/(2*sugar_variance));
  float d2 = dist(pos, sugar_center2);
  max += gmax * exp(-d2*d2/(2*sugar_variance));
  max += randomInt(-gmax/10, gmax/10);
  if (max < 0) max = 0;
  return max;
}

void main() {
  for (int x : 0..grid_width) {
    for (int y : 0..grid_width) {
      bool occupied = random(1.0) < occupiedFrac;
      int max_env_sugar_level = get_max_env_sugar_level(x, y);
      add(Agent {
        pos: float2(x + 0.5, y + 0.5),
        target_pos: float2(0),
        state: occupied ? AGENT_STATE_OCCUPIED : AGENT_STATE_UNOCCUPIED,
        sugar_level: occupied ? randomInt(min_start_sugar_level, max_start_sugar_level) : 0,
        metabolism: occupied ? 1 : 0,
        env_sugar_level: randomInt(0, max_env_sugar_level),
        max_env_sugar_level: max_env_sugar_level,
      });
    }
  }

  simulate(num_timesteps) {
    metabolise_and_growback,
    movement_request,
    movement_response,
    movement_transaction
  }
}
