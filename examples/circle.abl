agent Point {
  position float2 pos;
}

// Repulsive force parameter
float k_rep = 0.001;
// Attractive force parameter
float k_att = 0.001;
// Radius of agent (radius of repulsion)
float r = 5;
// Width/height of environment
float W = 500;
// Density of agents
param float rho = 0.01;
// Number of timesteps
param int num_timesteps = 100;

// Specify environment size
environment { max: float2(W) }

// Step function
// TODO Add keyword?
void move_point(Point in -> out) {
  float2 new_pos = in.pos;
  for (Point nx : near(in, 2*r)) {
    float pos_dist = dist(in.pos, nx.pos);
    float sep_dist = pos_dist - r;
    float2 force = float2(0.0);
    if (sep_dist < r) {
      float k = sep_dist > 0.0 ? k_att : -k_rep;
      // r or pos_dist here?
      force = k * sep_dist * (in.pos - nx.pos) / r;
    }
    new_pos += force;
  }
  out.pos = clamp(new_pos, float2(W));
}

void main() {
  // Determine population size and allocate agents
  int A_pop = int(W*W * rho);

  // initialization (sequential)
  for (int i : 0..A_pop) {
    add(Point {
      pos: random(float2(W))
    });
  }

  // simulation (parallel)
  simulate(num_timesteps) { move_point }

  save("points.out");
}
