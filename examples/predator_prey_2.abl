/*
  Predator-Prey is a simulation with three different agent types:
   - the predator, who follows the closest prey to eat and survive
   - the prey, who tries to escape from the predators and eats grass
   - the grass, which is eaten by preys

   NOTE 1: This version implements a hack for the add/remove, which only works on sequential backend (Mason). 
   NOTE 2: Implementation similar to FLAME-GPU version: https://github.com/FLAMEGPU/Tutorial/blob/master/examples/PreyPredator/src/model/XMLModelFile.xml
   https://github.com/FLAMEGPU/Tutorial/blob/master/examples/PreyPredator/src/model/functions.c
*/

agent Predator {
  position float2 pos;
  float2 dir;
  float2 steer;
  int life;
  bool active;
}
agent Prey {
  position float2 pos;
  float2 dir;
  float2 steer;
  int life;
  bool active;
}
agent Grass {
  position float2 pos;
  int dead_cycles;
  bool avail;
}


int getColor(Predator p) {
  if(p.active) return  0xff0000;
  else return 0xcc0000;
}
int getColor(Prey p) {
  if(p.active) return 0x0000ff;
  else return 0x0000cc;
}
int getColor(Grass g) {
  if(g.avail) return 0x00ff00;
  else return 0x00cc00;
}


// TODO Add this to the language, duh
float PI = 3.14159265358979323846;

// tunable model parameters
param float REPRODUCE_PREY_PROB = 0.05;
param float REPRODUCE_PREDATOR_PROB = 0.03;
param int GAIN_FROM_FOOD_PREDATOR = 75;
param int GAIN_FROM_FOOD_PREY = 50;
param int GRASS_REGROW_CYCLES = 100;

//Hard coded model parameters
float PRED_PREY_INTERACTION_RADIUS = 0.100; //The radius in which predators chase prey and prey run away from predators		
float PREY_GROUP_COHESION_RADIUS = 0.200; //The radius in which prey agents form cohesive groups
float SAME_SPECIES_AVOIDANCE_RADIUS = 0.035; //The radius in which agents of the same species will avoid each other (close proximity collision avoidance behaviour)
float GRASS_EAT_DISTANCE = 0.020; //The distance in which grass is eaten by prey
float PRED_KILL_DISTANCE = 0.020; //The distance in which prey are eaten by predators
float DELTA_TIME = 0.001; //Time step integral
float PRED_SPEED_ADVANTAGE = 2.000; //Speed multiplier to give predators an advan


param float prey_radius = 5.0;
param float predator_radius = 5.0;
param float prey_velocity = 0.1;
param float agent_density = 0.1;
param float predator_fraction = 0.1;
param int num_agents = 1000;

float env_size = sqrt(num_agents/agent_density);
environment { max: float2(env_size) }

float2 random_direction() {
  float phi = random(2*PI);
  return float2(sin(phi), cos(phi));
}



float2 boundPosition(float2 pos){ return clamp(pos, float2(env_size,env_size)); }


/* Prey step functions */
step prey_avoid_pred(Prey in -> out) {
  //  float2 prey_position = in.pos; float2 prey_velocity = in.dir; float2 average_center = float2(0.0f, 0.0f);
  float2 avoid_velocity = float2(0.0);
  for (Prey prey : near(in, PRED_PREY_INTERACTION_RADIUS)) {
    float separation = dist(in.pos, prey.pos);
    //Prey have a avoidance velocity which increases as the distance between them decreases
//    if (separation < (PRED_PREY_INTERACTION_RADIUS))
//	if (separation > 0.0f)
    avoid_velocity += PRED_PREY_INTERACTION_RADIUS / separation*(in.pos - prey.pos);
  }
  //Set the steering force to the avoidance force
  out.steer = avoid_velocity;
}

step prey_flock(Prey in -> out) {
//  float2 agent_position = float2(xmemory->x, xmemory->y);
  float2 group_center = float2(0.0);
  float2 group_velocity = float2(0.0);
  float2 avoid_velocity = float2(0.0);
  int group_centre_count = 0;
  for (Prey prey : near(in, PREY_GROUP_COHESION_RADIUS)) {
    if(prey.pos != in.pos){
      float separation = dist(in.pos, prey.pos); //length(agent_position - message_position);
      //Update Perceived global centre for grouping velocity
      group_center += prey.pos; //message_position;
      group_centre_count += 1;
      if (separation < (SAME_SPECIES_AVOIDANCE_RADIUS)) {
        if (separation > 0.0)
          avoid_velocity += SAME_SPECIES_AVOIDANCE_RADIUS/separation*(in.pos - prey.pos);
      }
    }
  }
  //Average nearby agents positions to find the centre of the group and create a velocity to move towards it 
  if (group_centre_count > 0){
    group_center /= group_centre_count;
    group_velocity = (group_center - in.pos); //agent_position);
  }
  //Add the grouping and avoidance velocities to the steer velocity (which already contains the predator avoidance velocity)
  out.steer += group_velocity + avoid_velocity;
}

step prey_move(Prey in -> out) {  
  float2 agent_position = in.pos;
  float2 agent_velocity = in.dir;
  float2 agent_steer = in.steer;	
  //Adjust the velocity according to the steering velocity
  agent_velocity += agent_steer;
  //Limit the speed of the avoidance velocity
  float current_speed = length(agent_velocity);
  if (current_speed > 1.0)
    agent_velocity = normalize(agent_velocity);
  //Integrate the position by applying moving according to the velocity
  agent_position += agent_velocity * DELTA_TIME;
  //Bound the position within the environment 
  agent_position = boundPosition(agent_position);
  //Update the agents position and velocity
  out.pos = agent_position;
  out.dir = agent_velocity;
  out.life = in.life-1;  //reduce life by one unit of energy
}

step prey_eaten(Prey in -> out) {
  bool eaten = false;
  int predator_id = -1;
  float closest_pred = PRED_KILL_DISTANCE;
  //Iterate the predator location messages until NULL is returned which indicates all messages have been read.
  for(Predator pred : near(in,PRED_KILL_DISTANCE)){
    //calculate distance between prey and predator
    float distance = length(pred.pos - in.pos);
    if (distance < closest_pred){
      //predator_id = pred_location_message->id;
      closest_pred = distance;
      eaten = true;
    }
  }
  //if one or more predators were within killing distance then notify the nearest predator that it has eaten this prey via a prey eaten message.
  if (eaten)
    removeCurrent(); // XXX FIXME? add_prey_eaten_message(prey_eaten_messages, predator_id);
  //return eaten value to remove dead (eaten == 1) agents from the simulation
  //return eaten;
}

step prey_eat_or_starve(Prey in -> out) {
  /* XXX FIXME
    int dead = 0;
        // Excercise 3.3
	//return dead value to remove dead agents from the simulation
  return dead;
  */
}

step prey_reproduction(Prey in -> out) {
  if(random(1.0) < REPRODUCE_PREY_PROB){
    add(Prey {
      pos: in.pos,
      dir: random_direction(),
      steer: float2(0),
      life: in.life / 2,
      active: true
    });
    //add the new agent to the simulation
    // add_prey_agent(agent_prey_agents, id, x, y, 1.0f, fx, fy, 0.0f, 0.0f, agent_prey->life);
  }
}

/* Predator step functions */
step pred_follow_prey(Predator in -> out) {
  float2 agent_position = in.pos;
  float2 agent_steer = float2(0,0);
  float2 closest_prey_position = float2(0,0);
  float closest_prey_distance = PRED_PREY_INTERACTION_RADIUS;
  bool can_see_prey = false;
  for(Prey prey : near(in,PRED_PREY_INTERACTION_RADIUS)){
    float separation = length(in.pos - prey.pos);
    //if distacne between predator and prey location is closest encountered so far then record the position and distance
    if ((separation < closest_prey_distance)){
      closest_prey_position = prey.pos;
      closest_prey_distance = separation;
      can_see_prey = true;
    }
  }
  //if there was a prey visible then create a velocity vector which will move the predator towards it.
  if (can_see_prey)
    agent_steer = closest_prey_position - agent_position;
  //set the steering vector
  out.steer = agent_steer;
}
step pred_avoid(Predator in -> out) {
  float2 avoid_velocity = float2(0,0);
  //Iterate the predator location messages until NULL is returned which indicates all messages have been read.
  for(Predator pred : near(in,SAME_SPECIES_AVOIDANCE_RADIUS)){
    float separation = length(in.pos - pred.pos);
    //Predators avoid each other with a force which increases as the distance between them decreases
    if (separation < (SAME_SPECIES_AVOIDANCE_RADIUS) && pred.pos != in.pos){
      if (separation > 0.0)  
        avoid_velocity += SAME_SPECIES_AVOIDANCE_RADIUS / separation*(in.pos - pred.pos);
    }
  }
  //Update the steering velocity which already has a velocity for chasing the nearest prey
  out.steer = avoid_velocity;
}
step pred_move(Predator in -> out) {
  float2 agent_position = in.pos;
  float2 agent_velocity = in.dir;
  float2 agent_steer = in.steer;
  //Adjust the velocity according to the steering velocity
  agent_velocity += agent_steer;
  //Limit the speed of the velocity
  float current_speed = length(agent_velocity);
  if (current_speed > 1.0){ agent_velocity = normalize(agent_velocity); }
  //Integrate the position by applying moving according to the velocity. Predators can move faster than prey by some factor.
  agent_position += agent_velocity * DELTA_TIME * PRED_SPEED_ADVANTAGE;
  //Bound the position within the environment 
  agent_position = boundPosition(agent_position);
  //Update the agents position and velocity
  out.pos = agent_position;
  out.dir = agent_velocity;
  out.life = in.life - 1; //reduce life by one unit of energy
}
step pred_eat_or_starve(Predator in -> out) {
  //bool dead = false;
  int life = in.life;
  for(Prey prey : near(in, PRED_KILL_DISTANCE)){ // XXX FIXME this is not 100% as in the orignal code, double check
    out.life = life + GAIN_FROM_FOOD_PREDATOR;
  }
  out.life = life;
  if(life < 0) removeCurrent();
}
step pred_reproduction(Predator in -> out) {
  if (random(1.0) < REPRODUCE_PREDATOR_PROB) {
    add(Predator { pos: in.pos, dir: random_direction(),  steer: float2(0), life: in.life / 2, active: true });
  }
}

/* Grass step functions */
step grass_eaten(Grass in->out){ // FIXME uncomplete
  out.dead_cycles = in.dead_cycles;
}
step grass_growth(Grass in->out){ // FIXME uncomplete
  out.dead_cycles = in.dead_cycles;
}


// TODO Use a real model here
/*
void update_prey(Prey in -> out) {
  // Get average position of predators
  float2 predPos = float2(0);
  int predNum = 0;
  for (Predator pred : near(in, prey_radius)) {
    predPos += pred.pos;
    predNum += 1;
  }

  out.pos = wraparound(in.pos + prey_velocity * in.dir, float2(env_size));
  if (predNum != 0) {
    // Move in direction away from predators
    out.dir = normalize(in.pos - predPos / predNum);
  } else {
    //out.dir = in.dir;
    out.dir = random_direction();
  }
}
void update_predator(Predator in -> out) {
  // Get average position of prey
  float2 preyPos = float2(0);
  int preyNum = 0;
  for (Prey prey : near(in, predator_radius)) {
    preyPos += prey.pos;
    preyNum += 1;
  }
  out.pos = wraparound(in.pos + predator_velocity * in.dir, float2(env_size));
  if (preyNum != 0) {
    // Move in direction towards prey
    out.dir = normalize(preyPos / preyNum - in.pos);
  } else {
    //out.dir = in.dir;
    out.dir = random_direction();
  }
}
*/

void main() {
  int num_predators = int(predator_fraction * num_agents);
  int num_prey = num_agents - num_predators;

  for (int i : 0..num_prey) {
    add(Prey {
      pos: random(float2(env_size)),
      dir: float2(0),
      steer: float2(0),
      life: 0,
      active: true
    });
  }

  for (int i : 0..num_predators) {
    add(Predator {
      pos: random(float2(env_size)),
      dir: float2(0),
      steer: float2(0),
      life: 0,
      active: true
    });
  }

  for(int i : 0..int(env_size)){
    for(int j : 0..int(env_size)){
      add(Grass { pos: float2(i,j), dead_cycles: 0, avail: true });
    }
  }


//  simulate(100) { update_prey, update_predator }
  simulate(100) { 
    //prey_follow_prey, 
    prey_avoid_pred,
    prey_flock, pred_avoid, 
    prey_move, pred_move, 
    grass_eaten, prey_eaten, 
    prey_eat_or_starve, pred_eat_or_starve, 
    pred_reproduction, prey_reproduction, grass_growth 
  }

  save("agents.out");
}

