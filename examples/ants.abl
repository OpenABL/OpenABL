/*
  Ants is a simulation of ants foraging from a nest.
  When they discovery a food source between obstacles, they establish a trail of pheromones between nest and food source.
  The model use two pheromones, which set up gradients and evaporate after some simulation steps, to the nest and to the food source respectively.
  
  The implementation is based on the sequential existing code taken from Mason, based on the following paper:
    + A Pheromone-Based Utility Model for Collaborative Foraging. Liviu Panait and Sean Luke. 
      In AAMAS 2004 http://cs.gmu.edu/~eclab/papers/panait04pheromone.pdf  
  However, this code has been mainly rewritten in order to exploit the parallelism exposed by OpenABL.  
  Here agent parallelsim is exposed twice: first, for each agent; second, for each location marked with a pheromone, for the evaporation step.    
*/

agent Ant {
  position float2 pos;
  float2 velocity;
  bool hasFood;
}

agent Pheromone {
  position float2 pos;
  float strenght;
}

agent Food {
  position float2 pos;
}


// TODO Add this to the language
float PI = 3.14159265358979323846;


/* Colors used for visualization */
int getColor(Pheromone p) {   
  int r = int(255 * p.strenght);
  return r << 16;
}

int getColor(Ant p) {
  return 0x0000ff;
}

int getColor(Food p) {  
  return 0x00ff00;
}





param float2 home_pos = float2(75,75);
param float2 food_pos = float2(25,25);

param int num_agents = 1000;
param float agent_density = 0.1;

param float ant_velocity = 0.3;
param float evaporationConstant = 0.999;
param float reward = 1.0;
param float updateCutDown = 0.9;
param float momentumProbability = 0.8;
param float randomActionProbability = 0.1;        
param float food_radius = 1.0;


// float max_pos = 100; // max x = max y = 100
int env_size = int( sqrt(num_agents/agent_density) );
environment { max: float2(env_size) }
int num_pheromones = env_size * env_size;


// TODO standard language library?

float2 random_direction() {
  float phi = random(2*PI);
  return float2(sin(phi), cos(phi));
}


// obstacle check, rewritten in vectorial form
// obstacles are two ellipses
bool obstacle(Ant ant){
	float2 f1 = float2(ant.pos.x-45, ant.pos.y-25);
	float2 s1 = f1 *  0.707;
	
	if( (s1.x+s1.y)*(s1.x+s1.y) / 36   + 
	    (s1.x-s1.y)*(s1.x-s1.y) / 1024 <= 1 )
		return true;
	
	float2 f2 = float2(ant.pos.x-35, ant.pos.y-70);
	float2 s2 = f2 *  0.707;
	if( (s2.x+s2.y)*(s2.x+s2.y) / 36 + 
	    (s2.x-s2.y)*(s2.x-s2.y) /1024 <= 1 )
		return true;

	return false; // no collision otherwise
}


// update ant
void update_ant(Ant in->out) {
  float2 global_velocity = float2(0, 0);
  float2 global_center = float2(0, 0);
  float2 collision_center = float2(0, 0);
  int interaction_count = 0;
  
  int food_count = 0;
  
  Food food = Food{ pos: food_pos };
  
  //  if the ant is close to food, generate pheromone
  // for each pheromone, for each ant  
//  for(float2 fx : food) {
  for (Pheromone px : near(food, food_radius)) {
    food_count += 1;  
  }
    
  
    
    // deposit food pheromone
    // xxx
//  }
  
  // follow home pheromone
  if(food_count > 0){
	
  }
  
   
  
  // random move
  out.pos = wraparound(in.pos + ant_velocity * in.velocity, float2(env_size));
  out.velocity = random_direction();
  
  // obstacle
  
  
  
//  out.pos = new_pos;
//  out.velocity = new_velocity;
}


// update pheromone
void update_pheromone(Pheromone in->out) {

  Food food = Food{ pos: food_pos }; // this should be global

  int ants_count = 0;  
  for (Ant ax : near(in, food_radius)) {  
    ants_count += 1;          
  }
  
  float new_strenght = in.strenght + ants_count * 0.1 - 0.001;
  // clamping
  if(new_strenght < 0.0) new_strenght = 0.0;    
  if(new_strenght > 1.0) new_strenght = 1.0;  
  
  out.strenght = new_strenght;  
}


void main() {    

  for (int i : 0..num_agents) {
    add(Ant {
      pos: home_pos,
      velocity: random(float2(-1), float2(1)),
      hasFood: false
    });
  }

  for (int i : 0..env_size ) {
    for (int j : 0..env_size ) {
      add(Pheromone {
        pos: float2(i,j),
        strenght: 0     
      });
    }
  }

  
  
  simulate(100) {
    update_ant,
    update_pheromone
  }

  save("ants.out"); 
}

