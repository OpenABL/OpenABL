/*
  Ants is a simulation of ants foraging from a nest.
  When they discovery a food source between obstacles, they establish a trail of pheromones between nest and food source.
  The model use two pheromones, which set up gradients and evaporate after some simulation steps, to the nest and to the food source respectively.
  
  The implementation is based on the sequential existing code taken from Mason, based on the following paper:
    + A Pheromone-Based Utility Model for Collaborative Foraging. Liviu Panait and Sean Luke. 
      In AAMAS 2004 http://cs.gmu.edu/~eclab/papers/panait04pheromone.pdf  
  However, this code has been mainly rewritten in order to exploit the parallelism exposed by OpenABL.  
  Here agent parallelsim is exposed twice: first, for each agent; second, for each location marked with a pheromone, for the evaporation step.    
*/

agent Ant {
  position float2 pos;
  float2 last_pos;
  float reward;
  bool hasFood;
}

agent Pheromone {
  position float2 pos;
  float food;
  float home;
}

agent Food {
  position float2 pos;
}


// TODO Add this to the language
float PI = 3.14159265358979323846;


/* Colors used for visualization */
int getColor(Pheromone p) {   
  int r = int(255 * p.food);
  int g = int(255 * p.home);
  int b = 0;
  return (r<<16) | (g<<8) | b;  
}

int getColor(Ant p) {
  return 0x0000ff;
}

int getColor(Food p) {  
  return 0xffffff;
}

// simulation model parameters
param float evaporationConstant = 0.999;
param float reward = 1.0;
param int num_ants = 1000;
param float cutDown = 0.9;                  // in [0,1]
param float momentumProbability = 0.8;      // in [0,1]
param float randomActionProbability = 0.1;  // in [0,1]

float2 home_pos = float2(75,75);
float2 food_pos = float2(25,25);
float ants_density = 0.1; // simulation scaling with constant density
float pheromone_radius = 1.0;

int env_size = int( sqrt(num_ants/ants_density) );
environment { max: float2(env_size) }
int num_pheromones = env_size * env_size;

float max(float a, float b){ if(a>b) return a; return b; }

bool random_boolean(float p){
  float val = random(1.0);
  if(val > p) return true;
  else return false;
} 


float2 random_direction() {
  float phi = random(2*PI);
  return float2(sin(phi), cos(phi));
}


// obstacle check, rewritten in vectorial form
// obstacles are two ellipses
bool obstacle(Ant ant){
  float2 f1 = float2(ant.pos.x-45, ant.pos.y-25);
  float2 s1 = f1 *  0.707;
  if( (s1.x+s1.y)*(s1.x+s1.y) / 36   + 
      (s1.x-s1.y)*(s1.x-s1.y) / 1024 <= 1 )
    return true;

  float2 f2 = float2(ant.pos.x-35, ant.pos.y-70);
  float2 s2 = f2 *  0.707;
  if( (s2.x+s2.y)*(s2.x+s2.y) / 36 + 
      (s2.x-s2.y)*(s2.x-s2.y) /1024 <= 1 )
    return true;
  return false; // no collision otherwise
}

bool isHome(float2 ant_pos){ return (dist(ant_pos, home_pos) <= 1.0); }
bool isFood(float2 ant_pos){ return (dist(ant_pos, food_pos) <= 1.0); }


/*
 Ant's step function logic is implemented in two steps: deposit and act.
 */
void ant_act(Ant in->out) {
  float new_reward = 0;
  float2 new_pos = float2(0,0); 
  
  Pheromone closest_pheromone = Pheromone { pos: new_pos, food: 0, home: 0 }; 
  float closest_dist = 1000;
  
  if(in.hasFood){ // follow home pheromone
    float home_max = 0;    
    for (Pheromone px : near(in, pheromone_radius)) {  
      home_max = max(home_max, px.home);    
      new_pos = px.pos;
      // check the closest pheromone
      float p_dist = dist(px.pos,in.pos);
      if(closest_dist < p_dist){
        closest_pheromone = px; 
        closest_dist = p_dist;
      }      
    }  
    if(home_max == 0){ // no home pheromones nearby
      if(random_boolean(momentumProbability))
        new_pos = in.pos + (in.pos - in.last_pos); // FIXME clamping? obstacles?
      else if(random_boolean(momentumProbability))
        new_pos = in.pos + random_direction();             
    }
    if(isHome(new_pos)){
      new_reward = closest_pheromone.home; // FIXME correct? 
      out.hasFood = false;
    }
  } // has food
  
  else { // no food yet, follow food pheromone
    float food_max = 0;    
    for (Pheromone py : near(in, pheromone_radius)) {  
      food_max = max(food_max, py.food);    
      new_pos = py.pos;
      // check the closest pheromone
      float p_dist = dist(py.pos,in.pos);
      if(closest_dist < p_dist){
        closest_pheromone = py; 
        closest_dist = p_dist;
      }      
    }
    if(food_max == 0){ // no food pheromones nearby
      if(random_boolean(momentumProbability))
        new_pos = in.pos + (in.pos - in.last_pos); // FIXME clamping? obstacles?
      else if(random_boolean(momentumProbability))
        new_pos = in.pos + random_direction();                   
    }
    if(isFood(new_pos)){
      new_reward = closest_pheromone.food; // FIXME correct? 
      out.hasFood = true;
    }
  } // no food yet
  
  
  out.last_pos = in.pos;  
  out.pos = new_pos; // FIXME clamping here? obstacles?
  out.reward = new_reward;
}


void pheromone_update(Pheromone in->out) {
  
  // deposit food & home pheromones
  float food_max = 0;
  float home_max = 0;
  
  for (Ant ax : near(in, pheromone_radius)) {  
    if(ax.hasFood){
      float food_m =  in.food * cutDown + ax.reward; // FIXME diagonal corner not handled      
      food_max = max(food_max, food_m);
    }
    else{
      float home_m =  in.home * cutDown + ax.reward; // FIXME diagonal corner not handled      
      home_max = max(home_max, home_m);     
    }    
  }
  
  out.food = food_max * evaporationConstant;
  out.home = home_max * evaporationConstant;
 
}


void main() {    

  for (int i : 0..num_ants) {
    float2 pos = random(float2(-1), float2(1)); 
    add(Ant {
      pos: pos,
      last_pos: pos,
      reward: 0,
      hasFood: false
    });
  }

  for (int i : 0..env_size ) {
    for (int j : 0..env_size ) {
      add(Pheromone {
        pos: float2(i,j),
        food: 0, home: 0    
      });
    }
  } 
  
  simulate(100) { pheromone_update, ant_act  }

  save("ants.out"); 
}

