/*
  Ants is a simulation of ants foraging from a nest.
  When they discovery a food source between obstacles, they establish a trail of pheromones between nest and food source.
  The model use two pheromones, which set up gradients and evaporate after some simulation steps, to the nest and to the food source respectively.
  
  The implementation is based on the sequential existing code taken from Mason, based on the following paper:
  A Pheromone-Based Utility Model for Collaborative Foraging. Liviu Panait and Sean Luke. In AAMAS 2004
  http://cs.gmu.edu/~eclab/papers/panait04pheromone.pdf
  
  However, this code has been mainly rewritten in order to exploit the parallelism exposed by OpenABL.  
  Here agent parallelsim is exposed twice: first, for each agent; second, each location marekd with a pheromone.    
*/

agent Ant {
  position float2 pos;
  float2 velocity;
  bool hasFood;
}

agent Pheromone {
  position float2 pos;
  float2 velocity;  
}


float min_pos = 0;
float max_pos = 100; // max x = max y = 100
environment {
  min: float2(min_pos),
  max: float2(max_pos)
}


float2 home = float2(75,75);
float2 food = float2(25,25);



float evaporationConstant = 0.999;
float reward = 1.0;
float updateCutDown = 0.9;
float momentumProbability = 0.8;
float randomActionProbability = 0.1;
        
float food_radius = 2.0;


// obstacle check, rewritten in vectorial form
// obstacles are two ellipses
bool obstacle(Ant ant){
	float2 f1 = float2(ant.pos.x-45, ant.pos.y-25);
	float2 s1 = f1 *  0.707;
	
	if( (s1.x+s1.y)*(s1.x+s1.y) / 36   + 
	    (s1.x-s1.y)*(s1.x-s1.y) / 1024 <= 1 )
		return true;
	
	float2 f2 = float2(ant.pos.x-35, ant.pos.y-70);
	float2 s2 = f2 *  0.707;
	if( (s2.x+s2.y)*(s2.x+s2.y) / 36 + 
	    (s2.x-s2.y)*(s2.x-s2.y) /1024 <= 1 )
		return true;

	return false; // no collision otherwise
}


// update ant
void update_ant(Ant in->out) {
  float2 global_velocity = float2(0, 0);
  float2 global_center = float2(0, 0);
  float2 collision_center = float2(0, 0);
  int interaction_count = 0;
  
  int food_count = 0;
  
  //  if the ant is close to food, generate pheromone
  // for each pheromone, for each ant  
  for(float2 fx : food) {
    for (Pheromone px : near(fx, food_radius)) {
      food_count += 1;  
    }
    
    // deposit food pheromone
    // xxx
  }
  
  // follow home pheromone
  if(count > 0){
	  
  }
  
   
  
  // random move
  
  
  // obstacle
  
  
  
  out.pos = new_pos;
  out.velocity = new_velocity;
}


// update pheromone
void update_pheromone(Pheromone in->out) {	

}


void main() {  

  for (int i : 0..num_agents) {
    add(Ant {
      pos: home,
      velocity: random(float2(-1), float2(1))
    });
  }

  simulate(100) {
    update_ant,
    update_pheromone
  }

  save("ants.out"); // XXX what?
}

