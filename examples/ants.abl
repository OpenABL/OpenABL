/*
  Ants is a simulation of ants foraging from a nest.
  When they discovery a food source between obstacles, they establish a trail of pheromones between nest and food source.
  The model use two pheromones, which set up gradients and evaporate after some simulation steps, to the nest and to the food source respectively.
  
  The implementation is based on the sequential existing code taken from Mason, based on the following paper:
    + A Pheromone-Based Utility Model for Collaborative Foraging. Liviu Panait and Sean Luke. 
      In AAMAS 2004 http://cs.gmu.edu/~eclab/papers/panait04pheromone.pdf  
  However, this code has been mainly rewritten in order to exploit the parallelism exposed by OpenABL.  
  Here agent parallelsim is exposed twice: first, for each agent; second, for each location marked with a pheromone, for the evaporation step.    
*/

agent Ant {
  position float2 pos;
  float2 last_pos;
  float reward;
  float max_home; // extra fields to allow the deposit in a second for loop
  float max_food; //  
  bool hasFood;
}

agent Pheromone {
  position float2 pos;
  float food;
  float home;
}

// TODO add this to the language
float PI = 3.14159265358979323846;
float SQRT2 = 1.41421356237;
float max(float a, float b){ if(a>b) return a; return b; }
float min(float a, float b){ if(a<b) return a; return b; }

// simulation model parameters
param float evaporationConstant = 0.999;//0.999;
param float initialReward = 1.0;
param int num_ants = 1000;
param float cutDown = .9; //0.63; //0.9;                  // in [0,1]
param float momentumProbability = 0.8;      // in [0,1]
param float randomActionProbability = 0.1;  // in [0,1]

float2 home_pos = float2(75,75);
float2 food_pos = float2(25,25);
float ants_density = 0.1;      // simulation scaling with constant density
float pheromone_radius = 2.83; //1.42; // but to get 9 points as in the orignal code we need to extend it 
float max_move = 2.83; //1.42 - 2.83; // in the orginal code is 2 per dimension, thus potentially 2*sqrt(2)=2.82842712475

int env_size = int( sqrt(num_ants/ants_density) );
environment { max: float2(env_size) }
int num_pheromones = env_size * env_size;

bool random_boolean(float p){
  float val = random(1.0);
  if(val > p) return true;
  else return false;
} 

float2 random_direction() {
  float phi = random(2*PI);
  return float2(sin(phi), cos(phi));
}

/* obstacle check, rewritten in vectorial form (obstacles are two ellipses) */
bool is_obstacle(float2 pos){
  float2 f1 = float2(pos.x-45, pos.y-25);
  float2 s1 = f1 *  0.707;
  if( (s1.x+s1.y)*(s1.x+s1.y) / 36 + (s1.x-s1.y)*(s1.x-s1.y) / 1024 <= 1 ) return true;
  float2 f2 = float2(pos.x-35, pos.y-70);
  float2 s2 = f2 *  0.707;
  if( (s2.x+s2.y)*(s2.x+s2.y) / 36 + (s2.x-s2.y)*(s2.x-s2.y) /1024 <= 1 )  return true;
  return false; // no collision otherwise
}

bool is_home(float2 ant_pos) { return dist(ant_pos, home_pos) <= 1.0; }
bool is_food(float2 ant_pos) { return dist(ant_pos, food_pos) <= 1.0; }

float2 random_move(Ant ant){
  if(random_boolean(momentumProbability)) // go to the same direction 
    return ant.pos + (ant.pos - ant.last_pos); 
  else if(random_boolean(randomActionProbability)) // go to a random direction
    return ant.pos + random_direction() * max_move;
  else
    return ant.pos; // no move 
}

/* colors used for visualization */
int getColor(Pheromone p) { 
  if(is_home(p.pos))     return 0x0000ff; // blue 
  if(is_food(p.pos))     return 0xff0000; // indigo 0x4B0082 - red 0xff0000  
  if(is_obstacle(p.pos)) return 0xffff00; // return 0xA9A9A9; // gray  
  int white = 0xffffff;  

  // Nikita snippet
  if (p.food != 0) {
    int r = int(255* (1.0-p.food) );
    int g = int(255* (1.0-p.food) );  
    int b = 255;        
      return ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | ((b & 0xFF) << 0);
  } else {
    int r = int(255* (1.0-p.home) );
    int g = 255;  
    int b = int(255* (1.0-p.home) );        
      return ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | ((b & 0xFF) << 0);
  }
//  return (r<<16) | (g<<8) | b;  // mix color channels  

/*  
  int r = int(255* (1.0-max(p.food,p.home)) );
  int g = int(255* (1.0-p.food) );  
  int b = int(255* (1.0-p.home) );    
  return ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | ((b & 0xFF) << 0); 
*/
}

int getColor(Ant p) {
//  if(p.reward == 1)    return 0xffff00; // yellow
  if(p.hasFood) return 0xff0000; // black
  else          return 0x000000; // red
}


/* Ant's step function logic is implemented in three steps: act_1, deposit and act_2. */

/*
 ant_act_1: each ants looks for the nearby home and food pheromone. Pheromoens are only read.
 (1st part of deposit)
 */
void ant_deposit(Ant in->out) {  
  float home_max = 0;
  float food_max = 0;
  for (Pheromone px : near(in, pheromone_radius)) {
    float K = dist(px.pos,in.pos) / pheromone_radius; // distance normalization constant
    float home_m = min(px.home * K * cutDown + in.reward,1); // FIXME diagonal corner not handled      
    home_max = max(home_max, home_m);    
    float food_m = min(px.food * K * cutDown + in.reward,1); // FIXME diagonal corner not handled  
    food_max = max(food_max, food_m);    
  }  
  
  if(in.hasFood) out.max_food = food_max; 
  else           out.max_home = home_max;   
  
  out.reward = 0; 
}

/* 
 pheromone_deposit: deposit of (home|food) pheromones. Each pheromone is written/updated.
 (2n part of deposit)
*/
void pheromone_deposit(Pheromone in->out) {
  // pheromone evaporation
  float food = in.food * evaporationConstant;  
  float home = in.home * evaporationConstant;
/*
  // find closest Ant (original code updated only the pheromone where the ant was lying)
  float closest_dist = env_size * env_size; // large enough value
  Ant closest_ant = Ant {pos:float2(0), last_pos:float2(0), reward:0, max_home:0, max_food:0, hasFood:false};  
  for (Ant ax : near(in, 0.9 )) {   //pheromone_radius
    float ant_dist = dist(ax.pos, in.pos); 
    if(closest_dist > ant_dist){
      closest_ant = ax;       
      closest_dist = ant_dist;
    }      
  }  
  // if there are ant nearby, deposit food & home pheromones
  if(closest_dist <= pheromone_radius){  
    if(closest_ant.hasFood) 
      food = closest_ant.max_food; //max(closest_ant.max_food,in.food);
    else
      home = closest_ant.max_home; //max(closest_ant.max_home,in.home);
  }
*/ 
  // pheromone contribution from near ants
  for (Ant ax : near(in, max_move)) {
    float D = dist(ax.pos,in.pos) / max_move;
    float K = D * 0.350; // distance normalization constant (very sensitive, tested 0.32)
    //float K = D * D * 0.340;
    if(ax.hasFood) {
      food = max(dist(in.pos,ax.pos) * ax.max_food * K, food);  
    }
    else {
      home = max(dist(in.pos,ax.pos) * ax.max_home * K, home);
    }
  }
  
  // final update
  out.food = min(food,1);
  out.home = min(home,1); 
}

/* act: the ant moves according to the nearby pheromones, or does a random move */
void ant_act(Ant in->out) {       
  float2 new_pos = in.pos;  
    
  float food_max = 0;    
  float home_max = 0;    
  float2 food_pos_max = float2(0,0);   
  float2 home_pos_max = float2(0,0);   
  
  float avoidSamePathProb = 0.25;
  
  // for each nearby pheromones
  for (Pheromone px : near(in, pheromone_radius)) {
    // check max food
    if(px.food > food_max || (food_max == px.food && random_boolean(avoidSamePathProb)) ){         
       food_max     = px.food;
       food_pos_max = px.pos;
    }
    // check max home 
    if(px.home > home_max || (home_max == px.home && random_boolean(avoidSamePathProb)) ){   
       home_max     = px.home;
       home_pos_max = px.pos;
    }     
  } // for 
  
  // (act) if the ant has food, follows the home pheromone 
  if(in.hasFood) { 
    if(home_max == 0)  // no home pheromones nearby
      new_pos = random_move(in);  // random move
    else
      new_pos = home_pos_max;   // otherwise, follow the pheromone
     
    if(is_home(new_pos)){      
      out.hasFood = false;
      out.reward = 1.0;
    }
  } 
  else { // the ants follows the food pheromone
    if(food_max == 0)  // no food pheromones nearby
      new_pos = random_move(in);
    else
      new_pos = food_pos_max;  
    
    if(is_food(new_pos)){      
      out.hasFood = true;
      out.reward = 1.0;
    }
  }
  
  // collision check 
  if(is_obstacle(new_pos) || !is_inside(new_pos, float2(env_size))) new_pos = in.last_pos;  
  
  // agent position update
  out.max_home = home_max;
  out.max_food = food_max;
  out.last_pos = in.pos;  
  out.pos      = new_pos;  
}

/* main simulation */
void main() {    

  for (int i : 0..env_size ) {
    for (int j : 0..env_size ) {
      add(Pheromone {
        pos: float2(i,j),
        food: 0, home: 0
      });
    }
  }

  for (int i : 0..num_ants) {
    float2 pos = home_pos; // + random(float2(-1), float2(1)) * 2; 
    add(Ant {
      pos: pos,
      last_pos: pos,
      reward: initialReward,
      max_home: 0, 
      max_food: 0,
      hasFood: false
    });
  }
  
  simulate(100) { ant_deposit, pheromone_deposit, ant_act  }

  save("ants.out"); 
}

