/*
  Predator-Prey is a simulation with two different agent types:
   - the predators follows the closest prey
   - the prey try to escape from the predators  
   This behavior is similar to the "Pursuit and Evasion" steering behavior.
*/

agent Predator {
  position float2 pos;
  float2 dir;
}
agent Prey {
  position float2 pos;
  float2 dir;
}

int getColor(Predator p) {
  return 0xff0000;
}
int getColor(Prey p) {
  return 0x0000ff;
}

float radius = 5.0;

param float agent_density = 0.1;
param float predator_fraction = 0.5;
param int num_agents = 1000;

float env_size = sqrt(num_agents/agent_density);
environment { max: float2(env_size) }

// TODO Use a real model here
void update_prey(Prey in -> out) {
  // Get average position of predators
  float2 predPos = float2(0);
  int predNum = 0;
  for (Predator pred : near(in, radius)) {
    predPos += pred.pos;
    predNum += 1;
  }

  out.pos = in.pos + in.dir;
  if (predNum != 0) {
    // Move in direction away from predators
    out.dir = normalize(in.pos - predPos / predNum);
  } else {
    out.dir = in.dir;
  }
}
void update_predator(Predator in -> out) {
  // TODO
  // out = in;
}

void main() {
  int num_predators = int(predator_fraction * num_agents);
  int num_prey = num_agents - num_predators;

  for (int i : 0..num_prey) {
    add(Prey {
      pos: random(float2(env_size)),
      dir: float2(0),
    });
  }

  for (int i : 0..num_predators) {
    add(Predator {
      pos: random(float2(env_size)),
      dir: float2(0),
    });
  }

  simulate(100) {
    update_prey,
    update_predator
  }

  save("agents.out");
}
